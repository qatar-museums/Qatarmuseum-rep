diff --git a/modules/callbacks.inc b/modules/callbacks.inc
index 26f802e..743a672 100644
--- a/modules/callbacks.inc
+++ b/modules/callbacks.inc
@@ -376,6 +376,23 @@ function entity_metadata_user_get_properties($account, array $options, $name, $e
 
     case 'theme':
       return empty($account->theme) ? variable_get('theme_default', 'bartik') : $account->theme;
+
+    case 'signature':
+      $return = array(
+        'value' => empty($account->signature) ? '' : $account->signature,
+        'format' => empty($account->signature_format) ? filter_default_format() : $account->signature_format,
+      );
+      return $return;
+
+    case 'timezone':
+      return empty($account->timezone) ? variable_get('date_default_timezone', ''): $account->timezone;
+
+    case 'picture':
+      return empty($account->picture) ? NULL : $account->picture;
+
+    case 'pass':
+      // Always return an empty string so this won't get exposed to RestWS etc.
+      return '';
   }
 }
 
@@ -388,6 +405,17 @@ function entity_metadata_user_set_properties($account, $name, $value) {
     case 'roles':
       $account->roles = array_intersect_key(user_roles(), array_flip($value));
       break;
+
+    case 'pass':
+      require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
+      $account->pass = user_hash_password($value);
+      break;
+
+    case 'signature':
+      // Handle these separately as it can happen that a user only specifies one value
+      $account->signature = !empty($value['value']) ? $value['value'] : '';
+      $account->signature_format = !empty($value['format']) ? $value['format'] : '';
+      break;
   }
 }
 
@@ -717,6 +745,21 @@ function entity_metadata_user_access($op, $entity = NULL, $account = NULL, $enti
 }
 
 /**
+ * Callback for validating user picture files.
+ */
+function entity_metadata_user_validate_picture($picture, $context) {
+  // Allow NULL values.
+  if (!isset($picture)) {
+    return TRUE;
+  }
+  // Check if the file is in fact a picture and if it is set temporarily
+  if (count(file_validate_is_image($picture)) || $picture->status != 0) {
+    return FALSE;
+  }
+  return TRUE;
+}
+
+/**
  * Access callback for restricted user properties.
  */
 function entity_metadata_user_properties_access($op, $property, $entity = NULL, $account = NULL) {
@@ -734,8 +777,18 @@ function entity_metadata_user_properties_access($op, $property, $entity = NULL,
       }
       // Allow edit access for own user name if the permission is satisfied.
       return $is_own_account && user_access('change own username', $account);
+    case 'picture':
+    case 'signature':
+      // Allow view access to anyone with access to the entity.
+      if ($op == 'view') {
+        return TRUE;
+      }
+      // Allow edit access for own picture and signature.
+      return $is_own_account;
+    case 'pass':
     case 'mail':
-      // Allow access to own mail address.
+    case 'timezone':
+      // Allow access to own password, mail address and timezone.
       return $is_own_account;
     case 'roles':
       // Allow view access for own roles.
@@ -812,17 +865,35 @@ function entity_metadata_taxonomy_access($op, $entity = NULL, $account = NULL, $
  * Access callback for file entities.
  */
 function entity_metadata_file_access($op, $file = NULL, $account = NULL, $entity_type) {
-  // We can only check access for the current user, so return FALSE on other accounts.
-  global $user;
-  if ($op == 'view' && isset($file) && (!isset($account) || $user->uid == $account->uid)) {
-    // Invoke hook_file_download() to obtain access information.
-    foreach (module_implements('file_download') as $module) {
-      $result = module_invoke($module, 'file_download', $file->uri);
-      if ($result == -1) {
+  if ($op == 'view' && isset($file)) {
+
+    // We copy some login from hook_file_download to make user pictures work.
+    // See: https://api.drupal.org/api/drupal/modules%21system%21system.api.php/function/hook_file_download/7
+    if (!file_prepare_directory($uri)) {
+      $uri = FALSE;
+    }
+    if (strpos(file_uri_target($file->uri), variable_get('user_picture_path', 'pictures') . '/picture-') === 0) {
+      if (!user_access('access user profiles', $account)) {
         return FALSE;
       }
+      else {
+        return TRUE;
+      }
     }
-    return TRUE;
+
+    // We can only check access for the current user, so return FALSE on other accounts.
+    global $user;
+    if (!isset($account) || $user->uid == $account->uid) {
+      // Invoke hook_file_download() to obtain access information.
+      foreach (module_implements('file_download') as $module) {
+        $result = module_invoke($module, 'file_download', $file->uri);
+        if ($result == -1) {
+          return FALSE;
+        }
+      }
+      return TRUE;
+    }
+    return FALSE;
   }
   return FALSE;
 }
@@ -898,6 +969,27 @@ function entity_metadata_create_node($values = array()) {
  * Callback to save a user account.
  */
 function entity_metadata_user_save($account) {
+  $picture = NULL;
+  if (!empty($account->picture)) {
+    $picture = $account->picture;
+    if(is_int($picture)) {
+      // The user_save() expects a picture object
+      $picture = file_load($picture);
+    }
+  }
+
+  if(!empty($account->is_new) && !empty($account->picture)) {
+    // We can't save a picture in a new account, so we save it an extra time w/o picture first.
+    $account->picture = NULL;
+    $edit = (array) $account;
+    // Don't save the hashed password as password.
+    unset($edit['pass']);
+    user_save($account, $edit);
+  }
+
+  // Restore the user picture property
+  $account->picture = $picture;
+
   $edit = (array) $account;
   // Don't save the hashed password as password.
   unset($edit['pass']);
diff --git a/modules/user.info.inc b/modules/user.info.inc
index 67a62b5..5c6e2a8 100644
--- a/modules/user.info.inc
+++ b/modules/user.info.inc
@@ -31,6 +31,15 @@ function entity_metadata_user_entity_property_info() {
     'access callback' => 'entity_metadata_user_properties_access',
     'schema field' => 'name',
   );
+  $properties['pass'] = array(
+    'label' => t("Password"),
+    'description' => t("The user's password (write only)."),
+    'getter callback' => 'entity_metadata_user_get_properties',
+    'setter callback' => 'entity_metadata_user_set_properties',
+    'required' => TRUE,
+    'access callback' => 'entity_metadata_user_properties_access',
+    'schema field' => 'pass',
+  );
   $properties['mail'] = array(
     'label' => t("Email"),
     'description' => t("The email address of the user account."),
@@ -105,6 +114,35 @@ function entity_metadata_user_entity_property_info() {
     'access callback' => 'entity_metadata_user_properties_access',
     'schema field' => 'theme',
   );
+  $properties['timezone'] = array(
+    'label' => t("Time zone"),
+    'description' => t("The user's time zone."),
+    'options list' => 'entity_property_timezone_options',
+    'getter callback' => 'entity_metadata_user_get_properties',
+    'setter callback' => 'entity_property_verbatim_set',
+    'access callback' => 'entity_metadata_user_properties_access',
+    'schema field' => 'timezone',
+  );
+  $properties['picture'] = array(
+    'label' => t("Picture"),
+    'description' => t("The user's picture."),
+    'type' => 'file',
+    'getter callback' => 'entity_metadata_user_get_properties',
+    'setter callback' => 'entity_property_verbatim_set',
+    'access callback' => 'entity_metadata_user_properties_access',
+    'validation callback' => 'entity_metadata_user_validate_picture',
+    'schema field' => 'picture',
+  );
+  $properties['signature'] = array(
+    'label' => t("Signature"),
+    'description' => t("The user's signature."),
+    'type' => 'text_formatted',
+    'getter callback' => 'entity_metadata_user_get_properties',
+    'setter callback' => 'entity_metadata_user_set_properties',
+    'access callback' => 'entity_metadata_user_properties_access',
+    'property info' => entity_property_user_signature_info(),
+    'auto creation' => 'entity_property_create_array',
+  );
   return $info;
 }
 
